[{"title":"自制Java科学计算器的计算方法","path":"2023/05/23/javajsqjsff/","text":"计算方法输入开始科学计算器的输入通常是存在多个运算符的，例如： 9+2-(1x3+5)÷7 这个的难点在于如何判断哪个是运算符，哪个是数值,Java中String有一个方法split()，这个方法可以让字符串以指定字符拆分成数组，所以我们可以在输入算式时，给每个运算符前后都加上空字符（空格），以利用空字符将运算符和数值区分开来 9 + 2 - ( 1 x 3 + 5 ) ÷ 7 过程接下来利用split(&quot;\\\\s&quot;)进行区分，其中\\\\s是正则表达式，意思为一个空字符及以上，代码如下： 12String str = &quot;9 + 2 - ( 1 x 3 + 5 ) ÷ 7&quot;;String[] strsz = str.split(&quot;\\\\s+&quot;); 这样我们就得到一个区分开数值和字符串的数组strsz，接下来就要开始计算的过程了。 计算判断在开始计算之前，我们需要判断数组哪个是数组，哪个是运算符，因为先乘除后加减，所以我们还需要判断哪个运算符先算，哪个后算。 首先先判断哪个是运算符，一般人都会选择用if函数，但试过就知道，完全判断不出来，但如果用switch函数就可以（目前我也不知道为什么）。 通过上面的方法就可以判断运算符了，接下来就要判断哪个先算，也就是我们需要一个优先级的判断，可是我们如何判断，他是运算符，本质上他就是一字符，不可以像数一样去比大小，所以我们可以为他定义一个值，一个优先级数，在用循环遍历整个strsz数组得到优先级最大的运算符，可是就有一个问题产生了，括号怎么办？ 我们开始定义的优先级数是常量，如果将其改为变量，用于使用遍历来判断优先级，所以我们可以使其判断到左括号时，使所有的优先级全部增加，遇到右括号时变回原来的优先级。 这样我们就可以判断谁是运算符，谁先算，然后我们需要定义一个量来记录他在数组的位置，因为遍历中定义的数是带不出去的。 通过上面就可以写出以下代码： 1234567891011121314151617181920212223242526272829303132333435363738int j = -1;//记录位置int jj = 0;//优先级值int n = 0;//优先级值的变量for (int i = 0; i &lt; strsz.length; i++) &#123; switch (strsz[i]) &#123; case &quot;(&quot;: n += 10; break; case &quot;)&quot;: n -= 10; break; case &quot;x&quot;: if (jj &lt; n + 4) &#123; jj = n + 4; j = i; &#125; break; case &quot;÷&quot;: if (jj &lt; n + 3) &#123; jj = n + 3; j = i; &#125; break; case &quot;-&quot;: if (jj &lt; n + 2) &#123; jj = n + 2; j = i; &#125; break; case &quot;+&quot;: if (jj &lt; n + 1) &#123; jj = n + 1; j = i; &#125; break; &#125; &#125; 一次的计算通过上面的步骤，可以得到要算的运算符，还记住了他所在数组的位置，接下来的计算就非常简单了，先利用switch函数判断他是什么运算符，将他左右两边的数进行相应的计算， 但还没开始算就报错了，因为这个数组是字符串数组，字符串里就算是123，他也无法计算，所以我们需要先将其变成Double类型，刚好就有这么一个方法Double.parseDouble()可以转换。 得出来的数我们放在数组j-1的位置上，会发现报错，原因同上，我们需要将其变回字符串类型，有个简单的方法，就是用&quot;&quot;+得出来的数。代码如下： 123456789101112131415161718switch (strsz[j]) &#123; case &quot;+&quot;: strsz[j - 1] = &quot;&quot; + (Double.parseDouble(strsz[j - 1]) + Double.parseDouble(strsz[j + 1])); break; case &quot;-&quot;: strsz[j - 1] = &quot;&quot; + (Double.parseDouble(strsz[j - 1]) - Double.parseDouble(strsz[j + 1])); break; case &quot;x&quot;: strsz[j - 1] = &quot;&quot; + Double.parseDouble(strsz[j - 1]) * Double.parseDouble(strsz[j + 1]); break; case &quot;÷&quot;: strsz[j - 1] = &quot;&quot; + Double.parseDouble(strsz[j - 1]) / Double.parseDouble(strsz[j + 1]); break;&#125; 一次的结果通过上面我们可以得到一次的计算结果，但我们需要的是全部的结果，所以我们需要将一次的计算结果拼回开始的样子，利用遍历拼接，代码如下： 123456str = &quot;&quot;;for (int i = 0; i &lt; strsz.length; i++) &#123; if (i != j &amp;&amp; i != j + 1) &#123; str += strsz[i] + &quot; &quot;; &#125;&#125; 这样我们就重新得到了一个字符串，在将其作为输入重新进行上面的步骤就可以得到结果。 最后循环我们可以使用while (true)来完成计算，结束的条件是字符串被拆成数组时长度为1，即没有运算符了。退出代码如下 123if (strsz.length == 1) &#123; break;&#125; 去除括号计算过程中会发现括号中只有一个数，没有运算符，此时继续计算会报错，所以我们需要去除这个形式的括号，在创建完数组后进行去除，并重新变回字符串，在拆分成数组，代码如下： 123456789101112131415161718for (int i = 0; i &lt; strsz.length - 2; i++) &#123; switch (strsz[i]) &#123; case &quot;(&quot;: &#123; switch (strsz[i + 2]) &#123; case &quot;)&quot;: strsz[i] = &quot;&quot;; strsz[i + 2] = &quot;&quot;; break; &#125; break; &#125; &#125;&#125;str = &quot;&quot;;for (int k = 0; k &lt; strsz.length; k++) &#123; str += strsz[k] + &quot; &quot;;&#125;strsz = str.split(&quot;\\\\s+&quot;); 得出结果在while结束后进行输出可以得到计算结果 也可以在while内的最后进行输出，可以得到计算过程"}]